import db from './connection.js';
import utilities from './utilities.js';

const CUDcsvLineIntoMySQL = async (tblName, csvLine, csvLineNum) => {
    const con = db.getConnection();
    let results;

    // Check if Id from csv (which is Procare unique id) matches ProcareId in my sql table
    
    try {
        results = await readRecByProcareId(tblName, csvLine['Id']);
        // U of CUD (UPDATE ONLY IF THERE IS A MISMATCH BETWEEN CSV and SQL)
        // Check if csv line is same as table row by comparing hash of the entire rec minus the id field            
        const hashCsvLine = utilities.getHash({...csvLine, Id: ''});
        // Pull in the relevant pieces of the mysql data record into an object for hash computation
        // We are comparing all the fields in the csv line (minus the Id) with the same fields in the sql table for a match
        const obj = {};
        for (const key in csvLine) {
            obj[key] = results.data[key];
        }
        const hashTableRec = utilities.getHash({...obj, Id: ''});

        if (hashCsvLine === hashTableRec) {
            // No need to process because the csv line's data is the same as the data in the sql table already
            console.log('');
            utilities.showMessage({type: 'INFO', msg: `CSV hash matches SQL hash --- rec needs no additional processing`});
        } else {
            // The data is different so we need to update the sql table record with what is in the csv line
            console.log("update needs to be done");
            utilities.showMessage({type: 'INFO', msg: `CSV hash does NOT matche SQL hash --- rec needs additional processing`});
            updateRec(tblName, csvLine, true);                   
        }
    } catch (e) {
        // ADD A SQL RECORD
        // C of CUD
            createRec(tblName, csvLine, csvLineNum);
    }                

};

// Fills up the Global Errors Array
const createRec = (tblName, csvLine, csvLineNum) => {
    const con = db.getConnection();
    
    // Id in the csv has to be put into the ProcareId field of the table and the Id field removed because it is auto generated 
    const newCsvLine = { ...csvLine, 
                            ProcareId: csvLine['Id'],
                            BatchTime: utilities.batchTime };
    delete newCsvLine.Id; // because it will be autogenerated in mysql
    
    con.query(`INSERT INTO ${tblName} SET ?`, newCsvLine, (err, res) => {                
        if (err) {                                
            utilities.showMessage({type: 'ERROR', msg: `Processing Line# ${csvLineNum} - ${csvLine}`});
            utilities.sqlErrorsArray.push({stoppedAtCsvLineNumber: csvLineNum, err: {code: err.code, errno: err.errno, msg: err.sqlMessage, sql: err.sql }});               
        } else {
            utilities.showMessage({type: 'INFO', msg: `Successfully created a mysql record from csv Line# ${csvLineNum}`});
        }
    });       
};




// This will be called to update the Firestore information in the mysql record
const updateRec1 = (tblName, data) => {
    const con = db.getConnection();

    con.query(`UPDATE ${tblName} SET FirestoreProcessDate = ?, FirestoreProcessCounter = ?, FirestoreId = ?, Status = ? WHERE Id = ?`, 
                            [Date.now(), 
                            data['FirestoreProcessCounter'], 
                            data['FirestoreId'],
                            data['Status'],
                            data['Id']
                            ], 
                            function (error, results, fields) {
                                if (error) {
                                    console.log('DDDDDDDDDDDDDDDDDDDDDDDDDDDDD',error);
                                }
                                utilities.showMessage({type: 'INFO', msg: `Updated ${results.changedRows} record(s) in SQL table`});
                            }
            );

};



const updateRec = (tblName, csvLine, makeStatusOne) => {
    const con = db.getConnection();

    // Make status 1 so that it will be picked up for SQL -> Firestore run.
    // For that run all status 1 records are read for processing and after processing the status is updated to 99
    if (makeStatusOne) {
        con.query(`UPDATE ${tblName} SET Name = ?, City = ?, Modified = ?, BatchTime = ?, Status = ? WHERE ProcareId = ?`, 
        [csvLine['Name'], 
        csvLine['City'], 
        new Date(), 
        utilities.batchTime,
        1,
        csvLine['Id']], 
        function (error, results, fields) {
            if (error) {
            console.log('CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC',error);
            }            
            utilities.showMessage({type: 'INFO', msg: `Updated ${results.changedRows} record(s) in SQL table`});
            });
    } else {
        con.query(`UPDATE ${tblName} SET Name = ?, City = ?, Modified = ?, BatchTime = ? WHERE ProcareId = ?`, 
        [csvLine['Name'], 
        csvLine['City'], 
        new Date(), 
        utilities.batchTime,                             
        csvLine['Id']], 
        function (error, results, fields) {
            if (error) {
            console.log('CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC',error);
            }
            utilities.showMessage({type: 'INFO', msg: `Updated ${results.changedRows} record(s) in SQL table`});
        });    
    }
};

const deleteRec = (tblName) => {

};

// Returns promise
const readRecByProcareId = (tblName, id) => {
    const con = db.getConnection();
    
    return new Promise((resolve, reject) => {
        con.query({
            sql: `SELECT * FROM ${tblName} WHERE ProcareId = ?`,
            timeout: 10000, // 10s
            values: [id]
          }, function (err, rows, fields) {
                if(!rows.length) {                             
                        reject({success: false, msg: `Record with ProcareId ${id} not found in ${tblName}`});  // Record not found in mysql
                } else {                
                        resolve({success: true, data: rows[0]});                                               // Record found in mysql
                }
            });
    });    
};

// Returns promise
const readRecById = (tblName, id) => {
    const con = db.getConnection();
    
    return new Promise((resolve, reject) => {
        con.query({
            sql: `SELECT * FROM ${tblName} WHERE Id = ?`,
            timeout: 10000, // 10s
            values: [id]
          }, function (err, rows, fields) {
            if(!rows.length) {                
                reject({success: false, msg: `Record with Id ${id} not found in ${tblName}`});
            } else {
                resolve({success: true, data: rows[0]});
            }
          });
    });    
};

const endConnection = () => {
    db.closeConnection();
};

const sqlService = {
    CUDcsvLineIntoMySQL,
    createRec,
    updateRec,
    updateRec1,
    deleteRec,
    readRecById,
    endConnection
};

export default sqlService;